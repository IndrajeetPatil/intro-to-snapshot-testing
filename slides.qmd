---
title: "Introduction to snapshot testing in R"
format:
  revealjs: 
    theme: simple
    slide-number: true
    preview-links: auto
    footer: "Source code for the slides can be found [here](https://github.com/IndrajeetPatil/intro-to-snapshot-testing)."
author: "Indrajeet Patil"
execute:
  echo: true
---

## Unit testing {.smaller}

The goal of a unit test is to capture the *expected* output of a function using *code* and making sure that *actual* output after any changes to the function matches the expected one.

::: incremental

- This insures against unintentionally changing function behaviour, or re-introducing already fixed bugs.

- It also makes sure that you will stay informed of any upstream dependency changes that might change the behaviour of your function.

- Tests also act as the most basic form of developer-focused documentation[^1].

[^1]: Ousterhout, J. K. (2018). *A Philosophy of Software Design*. Palo Alto: Yaknyam Press.

:::

## What is different about snapshot testing?

A **unit test** records the code to describe expected output.

</br>

<!-- Need to install the Quarto extension for fontawesome to work:
https://github.com/quarto-ext/fontawesome  -->

(actual) {{< fa regular file-code size=2xl >}} {{< fa solid arrows-left-right size=2xl >}} {{< fa solid file-code size=2xl >}} (expected)

</br>

A **snapshot test** records expected output in a separate, human-readable file.

</br>

(actual) {{< fa regular file-code size=2xl >}} {{< fa solid arrows-left-right size=2xl >}} {{< fa solid file-lines size=2xl >}} (expected)

## Why do we need snapshot testing? {.smaller}

If you develop R packages and have struggled to 

::: incremental

- test that printed text outputs look as expected
- test that an entire file is as expected
- test that generated graphical outputs look as expected
- write maintainable tests when complex output is included in source code
- update such tests *en masse* 

::: 

. . .

then you should be excited to know more about *snapshot tests* (aka *golden tests*)! ðŸ¤©

We will see how in these slides.

# Prerequisites

You are familiar with unit tests and how to write them using [`{testthat}`](https://testthat.r-lib.org/index.html).

If not, have a look at [this](https://r-pkgs.org/testing-basics.html) chapter from *R Packages* book.

## 

:::{.callout-important}

In the following slides, in all snapshot tests, I include the following line of code:

```r
local_edition(3)
```

**You don't need to do this in your package tests!**

Instead, you can use snapshot tests by activating the 3rd edition of `{testthat}`:

```r
Config/testthat/edition: 3
```

For more, see [this](https://testthat.r-lib.org/articles/third-edition.html) article.

:::

# Testing text outputs

Snapshot tests can be used to check that printing functions work as expected.

These functions are implemented to pretty-print R objects to the console, to create visually pleasing warning/error messages, etc.

## Example function {.smaller}

Let's say we want to write a unit test for the following function:

:::panel-tabset

### Source code

```{r}
print_movies <- function(keys, values) {
  paste0(
    "Movie: \n",
    paste0("  ", keys, ": ", values, collapse = "\n")
  )
}
```

### Output

```{r}
cat(print_movies(
  c("Title", "Director"),
  c("Salaam Bombay!", "Mira Nair")
))
```

:::

. . .

</br>

Note that we want to test that the printed output *looks* as expected. 

Therefore, we need to check for all the little bells and whistles in the printed output.

## Example test {.smaller}

Even testing this simple function is a bit painful because we need to keep track of every escape character, every space, etc. 

```{r, echo=FALSE}
library(testthat)
```


```{r}
test_that("`print_movies()` prints as expected", {
  expect_equal(
    print_movies(
      c("Title", "Director"),
      c("Salaam Bombay!", "Mira Nair")
    ),
    "Movie: \n  Title: Salaam Bombay!\n  Director: Mira Nair"
  )
})
```

. . .

With a more complex code, it'd be impossible for a human to reason about what the output is supposed to look like.

. . .

:::{.callout-important}

If this is a utility function used by many other functions, changing its behaviour would entail *manually* changing expected outputs for many tests.

This is not maintainable! ðŸ˜©

:::

## Alternative: Snapshot test {.smaller}

Instead, you can use `expect_snapshot()`!

. . .

The *first time* you run the test, it would generate a Markdown file with expected output.

```{r include = FALSE}
snapper <- local_snapshotter()
snapper$start_file("slides.qmd", "test")
```

```{r}
test_that("`print_movies()` prints as expected", {
  local_edition(3)
  expect_snapshot(cat(print_movies(
    c("Title", "Director"),
    c("Salaam Bombay!", "Mira Nair")
  )))
})
```

```{r, include = FALSE}
# Reset snapshot test
snapper$end_file()
snapper$start_file("slides.qmd", "test")
```

. . .

:::{.callout-warning}

The first time a snapshot is created, it becomes *the truth* against which future behaviour of function will be compared. 

Thus, it is **crucial** that you carefully check that the output is indeed as expected. ðŸ”Ž 

:::

## Human-readable Markdown file {.smaller}

Compared to our unit test

```r
"Movie: \n  Title: Salaam Bombay!\n  Director: Mira Nair"
```

notice how much more human-friendly the Markdown output is!

```md
Code
  cat(print_movies(c("Title", "Director"), c("Salaam Bombay!", "Mira Nair")))
Output
  Movie: 
    Title: Salaam Bombay!
    Director: Mira Nair
```

It is easy to *see* what the printed text output is *supposed* to look like.

. . . 

</br>

:::{.callout-note}

## More about snapshots files

- If a test is called `test-foo.R`, the snapshot will be saved to `test/testthat/_snaps/foo.md`.

- If there are multiple snapshot tests in a single file, corresponding snapshots will also share the same `.md` file.

- By default, `expect_snapshot()` will capture the code, the object values, and any side-effects.

:::

## What success looks like {.smaller}

If you run the test again, it'll succeed:

```{r}
test_that("`print_movies()` prints as expected", {
  local_edition(3)
  expect_snapshot(cat(print_movies(
    c("Title", "Director"),
    c("Salaam Bombay!", "Mira Nair")
  )))
})
```

```{r, include = FALSE}
# Reset snapshot test
snapper$end_file()
snapper$start_file("slides.qmd", "test")
```

. . .

</br>

:::{.callout-note}

### Why does my test not pass?

If you just generated a snapshot and ran the test again and it failed, this is most likely because your test is not deterministic. For example, if your function deals with random number generation.

In such cases, setting a seed (e.g. `set.seed(42)`) should help.

:::

## What failure looks like {.smaller}

But if we change the function (use `-` instead of `:` as a separator), the actual snapshot output won't match the expected one, and the test will fail:

:::panel-tabset

### Changes to function

```{.r code-line-numbers="4"}
print_movies <- function(keys, values) {
  paste0(
    "Movie: \n",
    paste0("  ", keys, "- ", values, collapse = "\n")
  )
}
```

```{r}
#| echo: false

print_movies <- function(keys, values) {
  paste0(
    "Movie: \n",
    paste0("  ", keys, "- ", values, collapse = "\n")
  )
}
```

### Test failure

```{r, error=TRUE}
test_that("`print_movies()` prints as expected", {
  local_edition(3)
  expect_snapshot(cat(print_movies(
    c("Title", "Director"),
    c("Salaam Bombay!", "Mira Nair")
  )))
})
```

:::

. . . 

Note that when the test fails, the message automatically provides a diff about what was expected (`-` rows) versus observed (`+` rows).

```r
- "    Title: Salaam Bombay!"
+ "    Title- Salaam Bombay!"
- "    Director: Mira Nair"
+ "    Director- Mira Nair"
```

## Fixing tests {.smaller}

Message accompanying failed tests make it explicit how we to fix them.

. . . 

- If the change was *deliberate*, you can accept the new snapshot as the current *truth*.

```r
* Run `snapshot_accept('slides.qmd')` to accept the change
```

- If this was *unexpected*, you can review the changes, and decide whether to change the snapshot or to correct the function behaviour instead.

```r
* Run `snapshot_review('slides.qmd')` to interactively review the change
```

. . . 

</br>

:::{.callout-tip}

## Fixing multiple snapshot tests

If this is a utility function used by many other functions, changing its behaviour would lead to failure of many snapshot tests. 

You can accept snapshots for *all* files with `snapshot_accept()`. And, of course, check the diffs to make sure that the changes are expected.

:::

## Capturing messages and warnings {.smaller}

So far we have tested text output printed to the console, but we can also use snapshots to capture messages, warnings, and errors.

:::panel-tabset

### message

```{r}
f <- function() message("Some info for you.")
test_that("f() produces expected message", {
  local_edition(3)
  expect_snapshot(f())
})
```

### warning

```{r}
g <- function() warning("Managed to recover.")
test_that("g() warns the user", {
  local_edition(3)
  expect_snapshot(g())
})
```

:::

. . . 

:::{.callout-tip}

Snapshot records both the *condition* and the corresponding *message*.

We can now rest assured that the users are getting informed the way we want! ðŸ˜Œ

:::

## Capturing errors {.smaller}

In case of an error, the function `expect_snapshot()` itself will produce an error. 
You have two ways around this:

:::panel-tabset

### Option-1

```{.r code-line-numbers="3"}
test_that("`log()` doesn't work when argument not numeric", {
  local_edition(3)
  expect_snapshot(log("x"), error = TRUE)
})
```

```{r, echo=FALSE}
test_that("`log()` doesn't work when argument not numeric", {
  local_edition(3)
  expect_snapshot(log("x"), error = TRUE)
})
```

### Option-2

```{.r code-line-numbers="3"}
test_that("`log()` doesn't work when argument not numeric", {
  local_edition(3)
  expect_snapshot_error(log("x"))
})
```

```{r, echo=FALSE}
test_that("`log()` doesn't work when argument not numeric", {
  local_edition(3)
  expect_snapshot_error(log("x"))
})
```

:::

. . . 

:::{.callout-tip}

### Which option should I use?

- If you want to capture both the code and the error message, use `expect_snapshot(..., error = TRUE)`.

- If you want to capture only the error message, use `expect_snapshot_error()`.

:::

# Testing graphical outputs

To create graphical expectations, we will use `{testthat}` extension package: [`{vdiffr}`](https://vdiffr.r-lib.org/).

## How does it work? {.smaller}

`{vdiffr}` introduces `expect_doppelganger()` to generate `{testthat}` expectations for graphics. It does this by generating SVG snapshots of entire graphics files!

. . . 

The figure to test can be:

- a `ggplot` object (from `ggplot2::ggplot()`)
- a `recordedplot` object (from `grDevices::recordPlot()`)
- or, more generally, any object with a `print()` method

. . . 

Just like other snapshot files, these are stored in `tests/testthat/_snaps/` folder, with a separate folder for each test file (`test-*.R`).

## Example function {.smaller}

Let's say we want to write a unit test for the following function:

:::panel-tabset

### Source code

```{r}
library(ggplot2)

create_scatter <- function() {
  ggplot(mtcars, aes(wt, mpg)) +
    geom_point(size = 3, alpha = 0.75) +
    geom_smooth(method = "lm")
}
```

### Output

```{r}
#| out.width: "70%"
create_scatter()
```

:::

. . .

</br>

Note that we want to test that the graphical output *looks* as expected, and this expectation is difficult to capture with a unit test.

## Graphical snapshot test {.smaller}

We can use `expect_doppelganger()` from `{vdiffr}` to test this!

. . .

The *first time* you run the test, it'd generate an `.svg` file with expected graphical output.

```{r include = FALSE}
library(vdiffr)

snapper <- local_snapshotter()
snapper$start_file("slides.qmd", "test")
```

```{r}
test_that("`create_scatter()` plots as expected", {
  local_edition(3)
  expect_doppelganger(
    title = "create scatter",
    fig = create_scatter(),
  )
})
```

```{r, include = FALSE}
# Reset snapshot test
snapper$end_file()
snapper$start_file("slides.qmd", "test")
```

. . .

</br>

:::{.callout-warning}

The first time a snapshot is created, it becomes *the truth* against which future behaviour of function will be compared. 

Thus, it is **crucial** that you carefully check that the output is indeed as expected. ðŸ”Ž 

:::

## What success looks like {.smaller}

If you run the test again, it'll succeed:

```{r}
test_that("`create_scatter()` plots as expected", {
  local_edition(3)
  expect_doppelganger(
    title = "create scatter",
    fig = create_scatter(),
  )
})
```

```{r, include = FALSE}
# Reset snapshot test
snapper$end_file()
snapper$start_file("slides.qmd", "test")
```

## What failure looks like {.smaller}

If we change the function, the new graphical plot output won't match the expected one, and the test will fail:

:::panel-tabset

### Changes to function

```{.r code-line-numbers="3"}
create_scatter <- function() {
  ggplot(mtcars, aes(wt, mpg)) +
    geom_point(size = 2, alpha = 0.85) +
    geom_smooth(method = "lm")
}
```

```{r}
#| echo: false

create_scatter <- function() {
  ggplot(mtcars, aes(wt, mpg)) +
    geom_point(size = 2, alpha = 0.85) +
    geom_smooth(method = "lm")
}
```

### Test failure

```{r, error=TRUE}
test_that("`create_scatter()` plots as expected", {
  local_edition(3)
  expect_doppelganger(
    title = "create scatter",
    fig = create_scatter(),
  )
})
```

:::

. . . 

Note that when the test fails, the message **cannot** provide a diff. 

Instead, `{testthat}` provides a Shiny app to compare changes in the output.

## Fixing tests {.smaller}

Running `testthat::snapshot_review()` launches a Shiny app we can use to either accept or reject the new output(s).

```{r}
#| echo: false
#| out.width: "60%"
knitr::include_graphics("images/shiny_app_graphics.mov")
```

# Testing entire files

Whole file snapshot testing tests that images, data frames, text files, etc. are as expected.

Since it works just like graphical snapshot tests, we won't discuss it in detail.

For more, see: [`expect_snapshot_file()`](https://testthat.r-lib.org/reference/expect_snapshot_file.html)

# Headaches 

It's not all kittens and roses when it comes to snapshot testing. We will now see some issues you might run into while using them. ðŸ¤•

## Failures in non-interactive environments {.smaller}

If your snapshots fail locally, you can just run `snapshot_review()`, but what if they fail in non-interactive environments? For example, on CI/CD platforms or during `R CMD Check`?

The easiest solution in such cases is to copy the new versions snapshots to your local folder and then run `snapshot_review()`.

We can discuss next where you can find the new snapshots.

## Accessing new snapshots {.smaller}

. . .

In local `R CMD Check`, you can find new snapshots in `.Rcheck` folder:

> package_name.Rcheck/tests/testthat/_snaps/

. . .

On CI/CD platforms, you can find snapshots as artifacts.

- [AppVeyor](https://www.appveyor.com/docs/packaging-artifacts/)

```{r, echo=FALSE, fig.height=1.5}
knitr::include_graphics("images/AppVeyor.png")
```

- [GitHub actions](https://github.com/r-lib/actions/tree/v2-branch/check-r-package)

```yaml
      - uses: r-lib/actions/check-r-package@v2
        with:
          upload-snapshots: true
```

## Code review with snapshot tests {.smaller}

Despite snapshot tests making the expected outputs more human-readable, given a big enough change and complex enough output, sometimes it can be challenging to review changes to snapshots. 

How do you review pull requests with such changes to snapshots? 

Next slide describes two approaches I prefer.

## {.smaller}

:::panel-tabset

### Option-1

Use tools provided for code review by hosting platform (like GitHub) (e.g. to review changes in SVG snapshots)

```{r}
#| echo: false
#| out.width: "70%"
knitr::include_graphics("images/github_pr.mov")
```

### Option-2

Locally open the PR branch and play around with the changes to see if the new behaviour makes sense. ðŸ¤· 

:::

##

:::{.callout-tip}

## Why are my snapshots for plots failing?! ðŸ˜”

Often, you will experience that your tests are failing even if you didn't change anything about your plotting function. 

Here are a few common reasons for such failures:

- R's graphics engine changed
- `{ggplot2}` itself changed
- non-determinism 
- reliance on system libraries

For these reasons, the visual regression tests tend to be fragile and by default not run on CRAN machines. They are only run on CI platforms.

:::

# Self-study 

In this presentation, we deliberately kept the example and the tests simple. 

To see a more realistic usage of snapshot tests, you should study some open-source test suites on your own. 

---

## Suggested repositories {.smaller}

::: columns

<!-- 1st column -->
::: {.column width="33%"}
### Print outputs

- [`{cli}`](https://github.com/r-lib/cli/tree/main/tests/testthat) (for testing command line interfaces)

- [`{pkgdown}`](https://github.com/r-lib/pkgdown/tree/main/tests/testthat) (for testing generated HTML documents)

- [`{dbplyr}`](https://github.com/tidyverse/dbplyr/tree/main/tests/testthat) (for testing printing of generated SQL queries)

- [`{gt}`](https://github.com/rstudio/gt/tree/master/tests/testthat) (for testing table printing)
:::

<!-- 2nd column -->
::: {.column width="33%"}
### Visualizations

- [`{ggplot2}`](https://github.com/tidyverse/ggplot2/tree/main/tests/testthat)

- [`{ggstatsplot}`](https://github.com/IndrajeetPatil/ggstatsplot/tree/main/tests/testthat)
:::

<!-- 3rd column -->
::: {.column width="33%"}
### Shiny apps 

- [`{shinytest2}`](https://github.com/rstudio/shinytest2/tree/main/tests/testthat)

- [`{designer}`](https://github.com/ashbaldry/designer/tree/dev/tests/testthat)

:::

:::

## Further reading

- `{testthat}` article on [snapshot testing](https://testthat.r-lib.org/articles/snapshotting.html)

- `{shinytest2}` article introducing its [workflow](https://rstudio.github.io/shinytest2/articles/shinytest2.html)

- Introduction to [golden testing](https://ro-che.info/articles/2017-12-04-golden-tests)

- Docs for [Jest](https://jestjs.io/docs/snapshot-testing) library in JavaScript, which inspired snapshot testing implementation in `{testthat}`

- Collection of packages for [unit testing](https://github.com/IndrajeetPatil/awesome-r-pkgtools/blob/main/README.md#unit-testing-) in R

# Find me at...

[Twitter](http://twitter.com/patilindrajeets)

[LikedIn](https://www.linkedin.com/in/indrajeet-patil-397865174/)

[GitHub](http://github.com/IndrajeetPatil)

[Website](https://sites.google.com/site/indrajeetspatilmorality/)

[E-mail](mailto:patilindrajeet.science@gmail.com)

# Thank You 

And Happy Snapshotting! ðŸ˜Š
